---
sidebar_position: 70
---

# 其他内容

## 目录
- 特殊内容
    - 需要了解并实现的特殊解法
    - 只需要了解的特殊解法
    - API 对比
    - 瓶颈期
- 算法基础
    - 时间复杂度
    - 排序算法
    - 数据结构
    - 递归公式
    - 主定理
    - 表达式
- 链表
    - 单向链表
    - 双向链表
- 二叉树
    - 类型
    - 遍历方式
- 图论
    - 算法对比

## 特殊内容

### 需要了解并实现的特殊解法：

#### Morris 遍历

- [94. Binary Tree Inorder Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal/)
- [144. Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/)

#### Floyd's Cycle Detection Algorithm（快慢指针）

- [141. Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/)
- [287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/)

#### Boyer–Moore 投票

- [169. 多数元素](https://leetcode-cn.com/problems/majority-element/)
- [229. 求众数 II](https://leetcode-cn.com/problems/majority-element-ii/)

#### 轮转算法

- [189. 轮转数组](https://leetcode-cn.com/problems/rotate-array/)

#### 快速幂

- [50. Pow(x, n)](https://leetcode-cn.com/problems/powx-n/)

#### 特殊排序

- [300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

#### 判断质数

- [204. 计数质数](https://leetcode-cn.com/problems/count-primes/)

#### 最近公共祖先

- [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)
- [1676. 二叉树的最近公共祖先 IV](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree-iv/)

#### 排列组合
- [62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)

#### 拓扑排序

- [210. 课程表 II](https://leetcode-cn.com/problems/course-schedule-ii/)

#### Dijkstra 算法

- [743. Network Delay Time](https://leetcode.com/problems/network-delay-time/)
- [787. Cheapest Flights Within K Stops](https://leetcode.com/problems/cheapest-flights-within-k-stops/)
- [1514. Path with Maximum Probability](https://leetcode.com/problems/path-with-maximum-probability/)

#### Bellman–Ford 算法

- [787. K 站中转内最便宜的航班](https://leetcode-cn.com/problems/cheapest-flights-within-k-stops/)
- [743. 网络延迟时间](https://leetcode-cn.com/problems/network-delay-time/)

### 只需要了解的特殊解法

牛顿迭代法，马拉车算法，KMP 算法，Prim 算法，Floyd-Warshall

### API 对比

以下为三种常见的编程语言 API 的对比表格，希望可以帮助你理解其他人的代码。

| Java        | Python      | C++         |
|----------- | ----------- | ----------- |
| [ArrayList](https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html) <ul><li>arr.add(val)</li><li>arr.insert(i, val)</li><li>arr.get(i)</li><li>arr.set(i, val)</li><li>arr.remove(val)</li></ul>   | [List](https://docs.python.org/3/tutorial/datastructures.html#more-on-lists) <ul><li>arr.append(val)</li><li>arr.insert(i, val)</li><li>arr[i]</li><li>arr[i] = val</li><li>arr.remove(val)</li></ul>        | [vector](https://www.cplusplus.com/reference/vector/vector/) <ul><li>arr.push_back(val)</li><li>arr.insert(i, val)</li><li>arr[i]</li><li>arr[i] = val</li><li> - </li></ul>       |
| [LinkedList](https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html) <ul><li>ll.add(val)</li><li>ll.addFirst(val) / offerFirst(val)</li><li>ll.addLast(val) / offerLast(val)</li><li>ll.getFirst() / peek() / peekFirst() </li><li>ll.getLast() / peekLast()</li></ul>   | None        |  [list](https://www.cplusplus.com/reference/list/list/) <ul><li>ll.push\_back(val)</li><li>ll.push\_front(val)</li><li>ll.push\_back(val)</li><li>ll.front()</li><li>ll.back()</li></ul>     |
|[Stack](https://docs.oracle.com/javase/8/docs/api/java/util/Stack.html) <ul><li>st.push(val)</li><li>st.pop()</li><li>st.peek()</li></ul>   | [Stack](https://docs.python.org/3/tutorial/datastructures.html#using-lists-as-stacks) <ul><li>st.append(va)</li><li>st.pop()</li><li>st[-1]</li></ul> | [stack](https://www.cplusplus.com/reference/stack/stack/) <ul><li>st.push\_back()</li><li>st.pop\_back()</li><li>st.top()</li></ul>      |
|[Queue](https://docs.oracle.com/javase/8/docs/api/java/util/Queue.html) <ul><li>q.add(val) / offer(val)</li><li>q.poll() / remove()</li><li>q.peek() / element()</li></ul>   | [deque](https://docs.python.org/3/library/collections.html) <ul><li>q.append(val)</li><li>q.popleft()</li><li>q[0]</li></ul> | [queue](https://www.cplusplus.com/reference/queue/queue/) <ul><li>q.push(val)</li><li>q.pop()</li><li>q.front()</li></ul>      |
| [PriorityQueue](https://docs.oracle.com/javase/8/docs/api/java/util/PriorityQueue.html) <ul><li>q.add(val) / offer(val)</li><li>q.poll() / remove()</li><li>q.peek()</li></ul>   | [heap](https://docs.python.org/3/library/heapq.html) <ul><li>heappush(q, val)</li><li>heappop(q)</li><li>q[0]</li></ul> | [priority\_queue](https://www.cplusplus.com/reference/queue/priority_queue/) <ul><li>q.push(val)</li><li>q.pop()</li><li>q.top()</li></ul>      |
| [HashSet](https://docs.oracle.com/javase/8/docs/api/java/util/HashSet.html) <ul><li>s.add(val)</li><li>s.contains(val)</li><li>s.remove(val)</li></ul>   | [Set](https://docs.python.org/3/tutorial/datastructures.html#sets) <ul><li>s.add(val)</li><li>bool(val in s)</li><li>s.remove(val)</li></ul> | [unordered_set](https://www.cplusplus.com/reference/unordered_set/unordered_set/) <ul><li>s.insert(val)</li><li>s.count(val)</li><li>s.erase(val)</li></ul>      |
| [HashMap](https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html) <ul><li>ht.put(i, val)</li><li>ht.get(i)</li><li>ht.remove(i)</li></ul>   | [Dictionaries](https://docs.python.org/3/tutorial/datastructures.html#dictionaries) <ul><li>ht[i] = value</li><li>ht[i]</li><li>del ht[i]</li></ul> | [unordered_map](https://www.cplusplus.com/reference/unordered_map/unordered_map/) <ul><li>ht.insert({i, val})</li><li>ht[i]</li><li>ht.erase(i)</li></ul>      |
| [TreeMap](https://docs.oracle.com/javase/8/docs/api/java/util/TreeMap.html) <ul><li>bt.put(i, val)</li><li>bt.get(i)</li><li>bt.ceilingEntry(i)</li><li>bt.higherEntry(i)</li></ul>   | None | [map](https://www.cplusplus.com/reference/map/map/) <ul><li>bt.insert(i, val)</li><li>bt[i]</li><li>bt.lower\_bound(i)</li><li>bt.upper\_bound(i)</li></ul>      |
| [binarySearch](https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#binarySearch-java.util.List-T-) <ul> <li>Collections.binarySearch(array, i)</li><li> - </li></ul>|[bisect](https://docs.python.org/3/library/bisect.html) <ul><li>bisect\_left(arr, i)</li><li>bisect\_right(arr, i)</li></ul> | [binary\_search](https://www.cplusplus.com/reference/algorithm/binary_search/) <ul><li>lower\_bound(arr.begin(), arr.end(), i)</li><li>upper\_bound(arr.begin(), arr.end(), i)</li></ul>      |
| [String](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html) <ul><li>st.charAt(i)</li><li>st.compareTo(st2)</li><li>st.contains(i)</li><li>Integer.parseInt(i)</li></ul>   |  [string](https://docs.python.org/3/library/string.html) <ul><li>st[i]</li><li>st == st2</li><li>bool(i in st)</li><li>int(i)</li></ul> |  [string](https://www.cplusplus.com/reference/string/string/) <ul><li>st[i]</li><li>st.compare(st2)</li><li>st.contains(i)</li><li>stoi(i)</li></ul>      |

### 瓶颈期

以下为常见的瓶颈期以及解决方法

| 瓶颈期         | 原因 | 解决方法     | 目标     | 
| ---------      | ---- | -----------  | -------  |
| 不理解题目   | <ul><li>平时做题没有计时的习惯，不知道自己写代码所需的时间，所以通过快速阅读来争取时间，忽略了题目要点</li><li>不够耐心和仔细</li></ul>     |<ul><li>仔细耐心阅读题目，边阅读边记下要点，如输入数据，限制条件等</li><li>使用例子帮助理解题目</li><li>对每题做题时间进行计时</li></ul> | 五分钟内能够理解题目含义 |
| 不理解题解   | <ul><li>没有观察到题目的特点以及使用该数据结构或者算法的原因</li><li>不熟悉题解描述的数据结构或者算法</li><li>题目难度过高，涉及了多种数据结构或者算法</li></ul> | <ul><li>仔细阅读多种类型的国区题解以及美区题解</li><li>列出题解中的数据结构以及算法，逐个学习</li><li>选择更低难度的题目</li></ul> | 能够理解大部分官方题解 |
| 做过的题目无法 AC   | <ul><li>做题只追求通过，没有思考和总结</li><li>没有学习多个解法，从而从不同角度看待问题，加深印象</li></ul> | <ul><li>做完题目之后进行回顾与总结，尝试不同解法</li><li>了解该类型题目的常用模式，使用场景以及常见错误</li></ul> | 做过的题目基本能够做出来 |
| 不知道题目是什么类型   | <ul><li>无法有效观察以及分析题目</li><li>不熟悉不同类型题目的特点</li></ul> | <ul><li>学习官方题解的前期分析步骤，观察题目的特点</li><li>总结不同类型题目的使用场景</li></ul> | 能够判断题目大概是什么类型 |
| 有思路，但是写不对   | <ul><li>思路不够清晰，忽略了重要的细节</li></ul> | <ul><li>写代码前认真思考每一个步骤</li><li>写代码前先利用例子来证明思路的正确性</li></ul> | 代码能够正确实现脑海中的思路|
| 不记得具体的库以及 API   | <ul><li>对编程语言不够熟练</li><li>不了解常用库</li></ul> | <ul><li>阅读官方题解，学习什么情况下可以用标准库</li><li>学习标准库的 API</li></ul> | 正确写出具体库以及 API |

## 算法基础

### ⨭ 时间复杂度

| 类型        | 表达式      |  例子       |
| ----------- | ----------- | ----------- |
| 常数        | O(1)        | <ul><li>加减乘除</li><li>获取元素属性</li></ul>        |
| 对数        | O(logn)     | <ul><li>二分查找</li><li>优先队列增删元素</li></ul>    |
| 线性        | O(n)        | <ul><li>遍历数组</li><li>遍历链表</li></ul>            |
| 线性方程    | O(nlogn)    | <ul><li>堆排序</li><li>归并排序</li></ul>              |
| 二次方      | O(n^2)      | <ul><li>遍历数组子对</li><li>数字相乘</li></ul>        |
| 多项式      | O(n^c)      | <ul><li>遍历数组子对（长度不定）</li><li>多重遍历</li></ul>        |
| 指数        | O(2^n)      | <ul><li>遍历所有子集合</li><li>回溯算法</li></ul>        |

### ⨦ 排序算法

| 类型        | 最好时间    |  平均时间   | 最坏时间    | 空间        |  稳定性     |
| ----------- | ----------- | ----------- | ----------- | ----------- | ----------- |
| 快速排序    | O(nlogn)    | O(nlogn)    | O(n^2)      | O(logn)     |  不稳定     |
| 归并排序    | O(nlogn)    | O(nlogn)    | O(nlogn)    | O(n)        |  稳定       |
| 堆排序      | O(nlogn)    | O(nlogn)    | O(nlogn)    | O(1)        |  不稳定     |
| 冒泡排序    | O(n)        | O(n^2)      | O(n^2)      | O(1)        |  稳定       |
| 插入排序    | O(n)        | O(n^2)      | O(n^2)      | O(1)        |  稳定       |
| 桶排序      | O(n)        | O(n)        | O(n^2)      | O(n)        |  稳定       |

### ⦜ 数据结构

| 类型（平均）| 获取元素    |  查找元素   | 插入元素    |
| ----------- | ----------- | ----------- | ----------- |
| 数组        | O(1)        | O(n)        | O(n)        |
| 链表        | O(n)        | O(n)        | O(1)        |
| 双向链表    | O(n)        | O(n)        | O(1)        |
| 栈          | O(1)        | O(n)        | O(1)        |
| 堆          | O(1)        | O(n)        | O(logn)     |
| 队列        | O(1)        | O(n)        | O(1)        |
| 哈希表      | O(1)        | O(1)        | O(1)        |
| 二叉搜索树  | O(logn)     | O(logn)     | O(logn)     |
| 跳表        | O(logn)     | O(logn)     | O(logn)     |

### ⦠ 递归公式

| 类型             | T(n)        |  例子       |
| -----------      | ----------- | ----------- |
| T(n)=T(n/2)+1    | O(logn)     | 二分查找    |
| T(n)=2T(n/2)+1   | O(n)        | 二叉树遍历  |
| T(n)=2T(n/2)+n   | O(nlogn)    | 归并排序    |
| T(n)=T(n−1)+n    | O(n^2)      | 插入排序    |
| T(n)=2T(n−1)+1   | O(2^n)      | 回溯算法    |

### ⧅ 主定理

当 a≥1, b≥2, c>0 且 T(n) 在非负区间内满足 T(n) = aT(n/b)+O(nc)，假定 T(0)=0，T(1)=O(1)，则

| 类型             | T(n)           |
| -----------      | -----------    |
| c<log(b)a        | O(n * log(b)a) |
| c=log(b)a        | O(n^c * logn)  |
| c>log(b)a        | O(n^c)         |

### ⦧ 表达式

| 类型             | 表达式           | 结果            |
| -----------      | -----------      | -----------     |
| 调和级数         | 1+1/2+1/3+…+1/n  | **log(e)n**  *(n→∞)*        |
| 自然对数         | (1+1/n)^n        | **e**  *(n→∞)*           |
| 等差数列         | n1+n2+n3+n4..n   | **n(n1+n)/2**       |
| 等比数列         | n1+n2+n3+n4..n   | **n1(1-q^n)/(1-q)** |
| 卡特兰数         | f(n)=f(0)*f(n-1)+f(1)*f(n-2)+ ... +h(n-1)*h(0)  | -                |

## 链表

![linked-list](https://raw.githubusercontent.com/resumejob/algorithm101/main/imgs/linked-list.png)

## 二叉树

### ⧉ 类型

| 类型             | 简介                                    |
| -----------      | -----------                             |
| 完全二叉树       | 除了最后一层的右边，其他节点都已经填满  |
| 满二叉树         | 每个节点有零或者两个子节点              |
| 完美二叉树       | 所有节点都被填满                        |

![binary-tree](https://raw.githubusercontent.com/resumejob/algorithm101/main/imgs/tree.png)

### ⨦ 遍历方式

| 类型             | 例子                                    |
| -----------      | -----------                             |
| 前序遍历         | 父节点 -> 左节点 -> 右节点              |
| 中序遍历         | 左节点 -> 父节点 -> 右节点              |
| 后序遍历         | 左节点 -> 右节点 -> 父节点              |
| 层序遍历         | 第一层 -> 第二层 -> 第三层              |

![tree-1](https://raw.githubusercontent.com/resumejob/algorithm101/main/imgs/tree-1.png)

![tree-2](https://raw.githubusercontent.com/resumejob/algorithm101/main/imgs/tree-2.png)


### 图论

| 算法          | 介绍                                    |  允许负权重值     | 可以检测出负权重环       | 时间复杂度        |
|--------------| -----------------------|----------------| --------------        | --------------- |
| Dilkstra     | 单源带权重的有向图最短路径   |❌             | ❌                    | O((V+E)logV)    |
| Bellman-Ford | 一般情况下的单源带权重的有向图最短路径  |✅   | ✅                     | O(VE)           |
| Floyd-Warshall | 所有结点对最短路径        |✅             | ❌                   | O(V^3)           |
