---
sidebar_position: 1
---

# 基础

## 面试标准
面试和竞赛不一样，即使一道题目你无法完全解答，你也可以从多个方面来展现自己的沟通以及解题能力。面试官会从不同角度来评价你的能力并给出分数：

| 分数      | 解题能力     | 代码能力 | 沟通能力 |
| -----     | -----------  | -------  | -------  |
| 0-20 分   | 不懂得如何分析题目，即使多次提示也无法理解题目 | 没有写任何代码 | 思路混乱，无法沟通|
| 20-40 分  | 经过提示后对题目有一定理解，能够给出思路       | 代码大幅偏离正确解法或者无法将思路转变成代码 | 能够与面试官简单沟通，并说出自己的理解 |
| 40-60 分  | 能够给出暴力解，经过提示后可以给出次优解       | 代码风格和架构有问题，代码有错误但没有检查出来 | 较清晰地表达自己的思路，但是与面试官互动不足 | 
| 60-80 分  | 能够给出次优解，经过提示可以给出最优解         | 代码逻辑没有明显问题，但是细节有不少问题 | 清晰表达自己的思路，与面试官对题目有一定探讨 | 
| 80-100 分 | 能够给出多种解法，并且分析不同解法的优劣       | 代码命名良好，架构清晰，核心代码有注释 | 清晰表达自己的思路，与面试官对题目进行深入探讨 |

## 瓶颈期

以下为常见的瓶颈期以及解决方法

| 瓶颈期         | 原因 | 解决方法     | 目标     | 
| ---------      | ---- | -----------  | -------  |
| 不理解题目   | <ul><li>平时做题没有计时的习惯，不知道自己写代码所需的时间，所以通过快速阅读来争取时间，忽略了题目要点</li><li>不够耐心和仔细</li></ul>     |<ul><li>仔细耐心阅读题目，边阅读边记下要点，如输入数据，限制条件等</li><li>使用例子帮助理解题目</li><li>对每题做题时间进行计时</li></ul> | 五分钟内能够理解题目含义 |
| 不理解题解   | <ul><li>没有观察到题目的特点以及使用该数据结构或者算法的原因</li><li>不熟悉题解描述的数据结构或者算法</li><li>题目难度过高，涉及了多种数据结构或者算法</li></ul> | <ul><li>仔细阅读多种类型的国区题解以及美区题解</li><li>列出题解中的数据结构以及算法，逐个学习</li><li>选择更低难度的题目</li></ul> | 能够理解大部分官方题解 |
| 做过的题目无法 AC   | <ul><li>做题只追求通过，没有思考和总结</li><li>没有学习多个解法，从而从不同角度看待问题，加深印象</li></ul> | <ul><li>做完题目之后进行回顾与总结，尝试不同解法</li><li>了解该类型题目的常用模式，使用场景以及常见错误</li></ul> | 做过的题目基本能够做出来 |
| 不知道题目是什么类型   | <ul><li>无法有效观察以及分析题目</li><li>不熟悉不同类型题目的特点</li></ul> | <ul><li>学习官方题解的前期分析步骤，观察题目的特点</li><li>总结不同类型题目的使用场景</li></ul> | 能够判断题目大概是什么类型 |
| 有思路，但是写不对   | <ul><li>思路不够清晰，忽略了重要的细节</li></ul> | <ul><li>写代码前认真思考每一个步骤</li><li>写代码前先利用例子来证明思路的正确性</li></ul> | 代码能够正确实现脑海中的思路|
| 不记得具体的库以及 API   | <ul><li>对编程语言不够熟练</li><li>不了解常用库</li></ul> | <ul><li>阅读官方题解，学习什么情况下可以用标准库</li><li>学习标准库的 API</li></ul> | 正确写出具体库以及 API |

## 做题要点

### 一道题目思考不超过 30 分钟
一道题目如果思考 30 分钟还是没有思路的话可以马上看官方题解，这样节省不少刷题的时间，如果官方题解涉及你不了解的知识点，可以先快速学习下，但是还是专注在当前的题目本身

### 代码之前需要写思路，核心代码需要写注释，方便过一段时间复习

```
# 时间复杂度：O(n^2)
# 空间复杂度：O(1)
# 思路：使用两重循环，找到所有可能的组合，然后判断它们的和是否等于 target
class Solution:
  def twoSum(self, nums: List[int], target: int) -> List[int]:
    n = len(nums)
    # 找第一个元素
    for i in range(n):
        # 找第二个元素
        for j in range(i + 1, n):
            # 判断是否等于 target
            if nums[i] + nums[j] == target:
                return [i, j]
    return []
```

### 专注在常规解法中，跳过不熟悉的解法
官方题解给出了多种解法，一般来说掌握前两种解法即可。特别的解法例如牛顿迭代法，马拉车算法，KMP 算法，以及带人名的特殊解法都不要求掌握。如果你看不懂解法的话，请在讨论群里进行讨论。

