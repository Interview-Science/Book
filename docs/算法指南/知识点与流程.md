---
sidebar_position: 30
---

# 知识点与流程

确定目标之后，我们需要将目标分解成小的知识点，并且逐个制定计划进行练习。

## 分解知识点
如果你觉得自己没有某个类型的题目，可以尝试抽丝剥茧来找到具体没有掌握哪些知识点才导致无法解题，以动态规划为例，你可以尝试问自己几个问题：

**你知道在什么时候使用它吗？**

如果你知道什么时候需要使用动态规划，代表你不理解动态规划的概念以及使用场景，这时候做题并不能掌握此知识点，你需要通过阅读学习资料学习动态规划的概念，使用场景，优缺点以及常规的实现方式。

**你知道它的解题步骤吗？**

对于每个类型的算法，你应该对其解题步骤有清楚的了解，《算法导论》对动态规划的步骤有清晰的讲解：

> 我们通常按如下 4 个步骤来设计一个动态规划算法：
> 1. 刻画一个最优解的结构特征。
> 2. 递归地定义最优解的值。
> 3. 计算最优解的值，通常采用自底向上的方法。
> 4. 利用计算出的信息构造一个最优解。
> 
> 步骤 1~3 是动态规划算法求解问题的基础。如果我们仅仅需要一个最优解的值，而非解本身， 可以忽略步骤4。如果确实要做步骤 4，有时就需要在执行步骤 3 的过程中维护一些额外信息，以便用来构造一个最优解。

学习这些步骤，并且在解题过程中严格按照步骤来分析与解题，能够保证你在正确的方向上。同样地，你需要阅读学习资料进行学习。

**你知道它的难点吗？**

动态规划难点在于找到状态转移方程，如果你发现你解不出动态规划的题目是因为没有找到状态转移方程的话。那么可以通过总结做过的动态规划题目的状态转移方程，来帮助你找到规律，从而掌握此知识点。例如常见的状态转移方程有以下几种（其中 A, B, C 为常数）：

| 形式                   | 类型 |
| -----                  | -----------  |
| F(i) = A * F(i-1) + B  | F(i) 与 F(i-1) 有关 | 
| F(i) = A \* F(i-1) + B * F(i-2) + C  | F(i) 与 F(i-1), F(i-2) 有关 | 
| F(i) = A * F(k) + B (0 < k < i)  | F(i) 与 F(k) 相关 | 
| F(i, j) = A \* F(i-1, j) + B \* F(i, j-1) + C \* F(i-1, j-1)  | F(i, j) 与 F(i-1, j), F(i, j-1), F(i-1, j-1) 相关 | 

	
**你知道它的实现细节吗？**

实现细节与编程语言有关，二维动态规划的题目中，如果你不熟悉二维矩阵的操作，也会影响你解题的能力，这时候你应该针对矩阵操作进行练习。

## 知识点列表

如果你没有足够的经验，你可能不知道自己没有掌握哪些知识点，以下表格列出了每个类型中面试要求的所有知识点，如果你刚开始接触算法练习的话可能不理解部分内容。不过没关系，在之后的制定计划中我们会提供这些知识点所需的学习资料以及题目。

### 时空复杂度

**常见的时间复杂度类型**

  O(1), O(log(N)), O(N), O(N^2) 等不同类型的时间复杂度含义

**时间复杂度的渐进上界与下界**

  Ω(N), Θ(N), O(N) 的区别以及使用场景
    
**时间复杂度的增长速度**

上述不同时间复杂度的增长速度对比
  
**递归树**

学习递归树概念，计算方式以及使用场景
  
**均摊时间复杂度**

学习均摊时间复杂度概念，计算方式以及使用场景
  
**常见算法的时间复杂度计算技巧**

针对常见的题型，了解其时间复杂度的计算技巧，例如动态规划，二叉树，NP 问题

### 编程语言基础

- 运算符优先级
- 建立数组，链表，队列等数据结构的不同方法
- 熟悉内置库以及 API 

**链表**

- 快慢指针技巧
- 遍历获得链表长度，利用长度解题
- 使用 dummy 节点减少边界情况
- 了解值传递以及引用传递
- 了解双向链表的使用场景与优势
- 某些情况下，可以先将链表存在数组中，然后使用数组解题
- 链表其他特殊解法与技巧

**二叉树**

- 树的不同形态与类型
- 树的前序，中序，后序，层序遍历
- 二叉树与递归的关系
- 理解父子节点数据与递归关系

**二叉搜索树**

- 树的增删查改
- 带统计信息的二叉搜索树

**前缀树**

- 树的实现
- 树与字符串的使用场景
- 树与位运算的使用场景

**线段树**

- 树的 6 个以上使用场景

**矩阵**

- 根据不同的语言特性，建立一个自定义初始值的矩阵
- 二维坐标转化为一维 (i * col + j)
- 不同遍历方式 （例如1）先遍历列再遍历行 2）倒着遍历）
- 转置和翻转（例如：翻转 90 度）

**数组**

- 获取倒数第 k 个元素
- 从后到前遍历
- 每 k 个元素遍历
- 在 i + len < k 的情况遍历
- 轮转数组
- 重写排序比较方式
- 前缀和
- 差分数组
- 等差等比数组

**栈**

- 前缀，中缀，后缀表达式
- 括号匹配中如何使用栈
- 基本计算器中如何使用栈
- 如何使用栈模拟递归
- 单调栈的使用场景

**堆**

- 数据统计量中的应用
- 最大堆，最小堆解决 Top k 问题
- 在滑动窗口或者数据流中的应用
- 堆与贪心算法

**二分查找**

- lower_bound 以及 upper_bound 两个 API 的使用场景与实现
- left 与 right 指针的初始值以及跳出循环的条件

**位运算**

- 位运算的运算律
- 位运算的特殊运用
- 二，八，十六进制转换

**双指针**

- 了解左右指针的含义
- 排序后使用双指针
- 双指针步骤

**滑动窗口**

- 了解左右指针的含义
- 了解滑动窗口的原理

**回溯**

- 回溯与动态规划
- 回溯的实现方式
- 时间复杂度

**分治**

- 使用递归树分析时间复杂度
- 分治与回溯

**动态规划**

- 动态规划与暴力解
- 四个常规步骤
- 状态转移方程
- 初始化条件
- Top Bottom & Botton Up
- 动态规划与 DFS
- 状态压缩
- 时间复杂度

**贪心**

- 贪心与动态规划
- 数学证明

**NP问题**

- 常见类型
- 时间复杂度

**图论**

- 图的表达方式
- 图的建立方式
- 图的特殊算法

**DFS**

- DFS 与 BFS
- DFS 与递归
- DFS 递归前后的状态恢复
- DFS 的步骤
- DFS 染色
- 拓扑排序

**BFS**

- BFS 的步骤
- 带权重的节点
- 时间复杂度分析

**并查集**

- 使用场景
- 并查集与 DFS，BFS
- 时间复杂度

**设计**

- 设计类题目技巧
- 拆分子函数
- 单独分析子函数

**克隆**

- 值传递与引用传递

**数学**

- 数学证明的方式与技巧
- 常见的数学定理与使用场景
- 特殊数学解的题

**极大极小化**

- 博弈论基础

**几何**

- 线段，向量基础
- 常见几何题类型以及核心点

## 算法面试流程

你可以通过观看模拟面试视频来了解面试流程：
- [interviewing.io](https://www.youtube.com/c/interviewingio/videos)
- [Google Coding Interview With A Normal Software Engineer](https://www.youtube.com/watch?v=rw4s4M3hFfs)

算法面试中需要保证自己完成了 A (Ask) C (Conform) T (Test) 三个步骤：

**Ask - 提问**

问清楚题目的输入输出以及输入规模，对应不同类型的输入你可以提出相应的问题，而且你也可以通过记录该输入的不同维度来进行解题，例如给定字符串，除了记录字符串本身之外，某些情况下还可以记录它的 ASCII 码，索引位置，出现频率等。

| 输入      | 输入规模 | 特点|
| -----     | :--------: | :---: |
| 数字      | 数字范围 | 是否是整数 |
| 字符串    | 字符串长度 | 字符集范围 |
| 数组      | 数组长度 | <ul><li>元素是否唯一</li><li>是否有序</li></ul> |
| 链表      | 链表长度 | <ul><li>单向还是双向链表</li><li>是否有环</li></ul> |
| 二叉树    | 节点数量 | <ul><li>是否是特殊类型的二叉树</li><li>是否平衡</li></ul> |
| 图        | 节点数量 | <ul><li>是否有环</li><li>是否是简单图</li><li>节点值的范围</li></ul> |

通过输入规模，也可以反推时间复杂度，从而判断可能使用哪些算法（注：这个技巧不适用全平台）：

| 范围      | 时间复杂度 | 可能的解法 |
| -----     | -----------  | -------  |
| 0 < n < 10^9  | O(log(n)) / O(根号n) | 二分查找，位运算，快速幂，数学解 |
| 0 < n < 10^6  | O(n)      | 栈，双指针，滑动窗口，哈希表，并查集，KMP，一维动态规划|
| 0 < n < 10^5  | O(nlog(n)) | 排序，排序后双指针/二分查找，分治，堆，Dijkstra 算法，线段树|
| 0 < n < 10^4  | O(n^2) | 双层遍历，二维动态规划，Bellman-Ford 算法|
| 0 < n < 200  | O(n^3) | 三层遍历，Floyd–Warshall 算法|
| 0 < n < 30  | O(2^n) / O(n!) | NP 问题，状态压缩的动态规划 |

**Conform - 确认**

确认分为两步：
1. 使用简单的例子验证自己的思路，并且向面试官解释你的思路。
2. 正式写代码之前要问面试官，**“现在我可以按照这个思路写代码了吗？”。**确保你的解法是面试官想要的解法。要记住，算法面试要实现面试官能理解并且期望你实现的解法，而不是仅仅正确的解法，即使代码正确但是没有向面试官解释清楚的话，最终的评价也不会太好。

**Test - 检查**

写完代码后，主动使用一两个例子来检查代码中是否出现问题，同时也可以在检查的过程中添加遗漏的注释，改正不规范的变量命名。

## 常见问题

### 介绍

#### 对简历不熟悉，没有提前准备自我介绍

#### 表达过程出现太多“呃”

#### 缺乏亮点

#### 缺乏和面试官的互动

### 做题过程

#### 没有问数据范围

#### 直接要 hint

#### 没有找到好的例子

#### 没有使用文档，没有好的记录

#### 没有理解问题

#### 缺乏注释

#### 缺乏主动检查
