---
sidebar_position: 30
---

# 知识点与流程

确定目标之后，我们需要将目标分解成小的知识点，并且逐个制定计划进行练习。

## 分解知识点
如果你觉得自己没有某个类型的题目，可以尝试抽丝剥茧来找到具体没有掌握哪些知识点才导致无法解题，以动态规划为例，你可以尝试问自己几个问题：

**你知道在什么时候使用它吗？**

如果你知道什么时候需要使用动态规划，代表你不理解动态规划的概念以及使用场景，这时候做题并不能掌握此知识点，你需要通过阅读学习资料学习动态规划的概念，使用场景，优缺点以及常规的实现方式。

**你知道它的解题步骤吗？**

对于每个类型的算法，你应该对其解题步骤有清楚的了解，《算法导论》对动态规划的步骤有清晰的讲解：

> 我们通常按如下 4 个步骤来设计一个动态规划算法：
> 1. 刻画一个最优解的结构特征。
> 2. 递归地定义最优解的值。
> 3. 计算最优解的值，通常采用自底向上的方法。
> 4. 利用计算出的信息构造一个最优解。
> 
> 步骤 1~3 是动态规划算法求解问题的基础。如果我们仅仅需要一个最优解的值，而非解本身， 可以忽略步骤4。如果确实要做步骤 4，有时就需要在执行步骤 3 的过程中维护一些额外信息，以便用来构造一个最优解。

学习这些步骤，并且在解题过程中严格按照步骤来分析与解题，能够保证你在正确的方向上。同样地，你需要阅读学习资料进行学习。

**你知道它的难点吗？**

动态规划难点在于找到状态转移方程，如果你发现你解不出动态规划的题目是因为没有找到状态转移方程的话。那么可以通过总结做过的动态规划题目的状态转移方程，来帮助你找到规律，从而掌握此知识点。例如常见的状态转移方程有以下几种（其中 A, B, C 为常数）：

| 形式                   | 类型 |
| -----                  | -----------  |
| F(i) = A * F(i-1) + B  | F(i) 与 F(i-1) 有关 | 
| F(i) = A \* F(i-1) + B * F(i-2) + C  | F(i) 与 F(i-1), F(i-2) 有关 | 
| F(i) = A * F(k) + B (0 < k < i)  | F(i) 与 F(k) 相关 | 
| F(i, j) = A \* F(i-1, j) + B \* F(i, j-1) + C \* F(i-1, j-1)  | F(i, j) 与 F(i-1, j), F(i, j-1), F(i-1, j-1) 相关 | 

	
**你知道它的实现细节吗？**

实现细节与编程语言有关，二维动态规划的题目中，如果你不熟悉二维矩阵的操作，也会影响你解题的能力，这时候你应该针对矩阵操作进行练习。

## 知识点列表

如果你没有足够的经验，你可能不知道自己没有掌握哪些知识点，以下表格列出了每个类型中面试要求的所有知识点，如果你刚开始接触算法练习的话可能不理解部分内容。不过没关系，在之后的制定计划中我们会提供这些知识点所需的学习资料以及题目。

| 主题      | 需要掌握的内容 | 出现频率 |
| -----     | -----------  | -------  |
| 链表      | <ul><li>快慢指针技巧</li><li>遍历获得链表长度，利用长度解题</li><li>使用 dummy 节点减少边界情况</li><li>了解值传递以及引用传递</li><li>了解双向链表的使用场景与优势</li><li>某些情况下，可以先将链表存在数组中，然后使用数组解题</li><li>链表其他特殊解法与技巧</li></ul> | 低 | 
| 二叉树  | <ul><li>树的不同形态与类型</li><li>树的前序，中序，后序，层序遍历</li><li>二叉树树与递归的关系</li><li>理解父子节点数据与递归关系</li></ul> | 中 | 
| 二叉搜索树  | <ul><li>树的增删查改</li><li>带统计信息的二叉搜索树</li></ul> | 中 | 
| 前缀树  | <ul><li>树的实现</li><li>树与字符串的使用场景</li><li>树与位运算的使用场景</li></ul> | 中 | 
| 栈      | <ul><li>前缀，中缀，后缀表达式</li><li>括号匹配中如何使用栈</li><li>基本计算器中如何使用栈</li><li>如何使用栈模拟递归</li><li>单调栈的使用场景</li></ul> | 高 | 
| 堆      | <ul><li>数据统计量中的应用</li><li>最大堆，最小堆解决 Top k 问题</li><li>在滑动窗口或者数据流中的应用</li><li>堆与贪心算法</li></ul> | 高 | 

（其他主题补充中）

## 算法面试流程

你可以通过观看模拟面试视频来了解面试流程：
- [interviewing.io](https://www.youtube.com/c/interviewingio/videos)
- [Google Coding Interview With A Normal Software Engineer](https://www.youtube.com/watch?v=rw4s4M3hFfs)

算法面试中需要保证自己完成了 A (Ask) C (Conform) T (Test) 三个步骤：

**Ask - 提问**

问清楚题目的输入输出以及输入规模，对应不同类型的输入你可以提出相应的问题：

| 输入      | 输入规模 | 特点|
| -----     | :--------: | :---: |
| 数字      | 数字范围 | 是否是整数 |
| 字符串    | 字符串长度 | 字符集范围 |
| 数组      | 数组长度 | <ul><li>元素是否唯一</li><li>是否有序</li></ul> |
| 链表      | 链表长度 | <ul><li>单向还是双向链表</li><li>是否有环</li></ul> |
| 二叉树    | 节点数量 | <ul><li>是否是特殊类型的二叉树</li><li>是否平衡</li></ul> |
| 图        | 节点数量 | <ul><li>是否有环</li><li>是否是简单图</li><li>节点值的范围</li></ul> |

通过输入规模，也可以反推时间复杂度，从而判断可能使用哪些算法（注：这个技巧不适用全平台）：

| 范围      | 时间复杂度 | 可能的解法 |
| -----     | -----------  | -------  |
| 0 < n < 10^9  | O(log(n)) / O(根号n) | 二分查找，位运算，快速幂，数学解 |
| 0 < n < 10^6  | O(n)      | 栈，双指针，滑动窗口，哈希表，并查集，KMP，一维动态规划|
| 0 < n < 10^5  | O(nlog(n)) | 排序，排序后双指针/二分查找，分治，堆，Dijkstra 算法，线段树|
| 0 < n < 10^4  | O(n^2) | 双层遍历，二维动态规划，Bellman-Ford 算法|
| 0 < n < 200  | O(n^3) | 三层遍历，Floyd–Warshall 算法|
| 0 < n < 30  | O(2^n) / O(n!) | NP 问题，状态压缩的动态规划 |

**Conform - 确认**

确认分为两步：
1. 使用简单的例子验证自己的思路，并且向面试官解释你的思路。
2. 正式写代码之前要问面试官，**“现在我可以按照这个思路写代码了吗？”。**确保你的解法是面试官想要的解法。要记住，算法面试要实现面试官能理解并且期望你实现的解法，而不是仅仅正确的解法，即使代码正确但是没有向面试官解释清楚的话，最终的评价也不会太好。

**Test - 检查**

写完代码后，主动使用一两个例子来检查代码中是否出现问题，同时也可以在检查的过程中添加遗漏的注释，改正不规范的变量命名。
