---
sidebar_position: 50
---

# 电商系统

## 功能性需求与核心指标

### 功能性需求
1. 用户浏览商品列表
2. 用户购买商品

### 核心指标
1. 浏览商品的响应时间
1. 购买商品的一致性

## 基础架构

### 读阶段

![shopping1](/img/system/shopping1.svg)

1. 客户端点击首页或者通过搜索向服务端请求商品列表（无个人推荐算法）
2. 服务端返回商品列表


### 写阶段

![shopping3](/img/system/shopping3.svg)

1. 客户端点击购买商品
2. 服务端验证用户后，检查与更新库存
3. 服务端通知客户端进行支付
4. 客户端支付成功后，支付系统通知服务端，服务端更新数据库并返回信息给客户端以及商家
5. 若客户端超时没有进行支付，支付系统通知服务端，服务端更新库存，返回信息给客户端以及商家

## 瓶颈分析

**核心问题：读阶段对于同样的商品列表需要重复生成与处理**

解决方案：缓存首页，热门搜索页面以及商品页，服务器使用后台线程固定更新缓存

**核心问题：写阶段业务强耦合，其中一个环节出现故障会影响整个流程**

解决方案：使用消息队列解耦

**次要问题：大流量下，对于库存少的商品，需要处理大量无效流量**

解决方案：使用限流器以及消息队列进行限流

## 进阶架构


### 读阶段

![shopping2](/img/system/shopping2.svg)

1. 客户端点击首页或者通过搜索向服务器请求商品列表
2. 服务器查询缓存服务器，如果在缓存中则直接返回，否则请求下游服务器
3. 下游服务器使用后台线程定期更新缓存


### 写阶段

![shopping4](/img/system/shopping4.svg)

1. 客户端点击购买商品
2. 限流器过滤无效流量
3. 网络服务端验证用户后，将购买事件发送给消息队列（有多个组件订阅此事件，例如服务器，数据分析系统，日志与监控系统）
4. 服务端检查库存，数据分析系统记录购买事件的相关信息并进行分析，日志与监控系统记录购买事件
5. 如果库存不足的话，服务器返回失败，如果库存充足的话，服务器更新库存并且通知客户进行支付
6. 客户端进行支付
7. 客户端支付成功/失败后，支付系统将支付事件发送给消息队列（有多个组件订阅此事件，例如服务器，数据分析系统，日志与监控系统）

## 瓶颈分析

**核心问题：如何防止订单重复支付？**

解决方案：订单重复支付有几种可能的原因：
1. 支付成功，但是消息没有成功发送到客户端，客户端误以为支付超时，用户重新支付
2. 系统中的组件（消息队列，服务器）不知道支付成功，组件进行支付重试

对于每个订单（即使是相同的商品和数量）生成独一无二的订单 ID，将用户每次点击支付都当成单独的行为。当用户尝试重新支付同一个订单，由于数据库该订单 ID 的支付状态是已支付，所以重新支付失败。

**次要问题：重度依赖消息队列，需要关注消息队列的特性，例如消息的有序性，重试的方法与间隔，最少一次送达或刚好一次送达对业务产生的影响**

解决方案：研究以及学习消息队列的内部实现

**次要问题：在大流量下，可能出现大量用户支付成功或者超时，如何减少对数据库的压力？**
解决方案：使用事务合并的方法，尝试合并多个支付成功或者超时的消息，然后再更新数据库的状态


## 面试官可能提出的问题

- 如何防止错误更新库存或者库存更新不及时导师商品超卖或者少卖？
- 如果电商系统流量过大，有哪些策略可以执行？
